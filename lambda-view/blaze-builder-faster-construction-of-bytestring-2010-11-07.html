<div>
Hi, I am <a href="http://people.inf.ethz.ch/meiersi">Simon Meier</a>, a swiss Haskell enthusiast currently pursuing his PhD in computer science at <a href="http://www.ethz.ch/">ETH Zurich</a>. In this blog post, I'll introduce you to the <a href="http://hackage.haskell.org/package/blaze-builder">blaze-builder</a>&nbsp;library.

</div>
<div>
The blaze-builder library provides you with a Builder type that you can use to <i>efficiently</i> construct sequences of bytes represented in a packed form as a strict or lazy bytestring. Hence, typical use cases for a Builder are saving your application data in a space efficient binary form to a file or sending a response to some request over the network.

</div>
<div>
Probably, you know about the <a href="http://hackage.haskell.org/package/binary">binary</a>&nbsp;package, which also provides a Builder type in the <a href="http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/Data-Binary-Builder.html">Data.Binary.Builder</a>&nbsp;module targeting exactly the same usecase as our Builder. This is no coincidence. During this year's Google Summer of Code, <a href="http://jaspervdj.be/">Jasper Van der Jeugt</a>&nbsp;and I developed the blaze-builder library to overcome performance shortcomings of Data.Binary.Builder with respect to the specific needs of the <a href="http://jaspervdj.be/blaze">blaze-html</a> HTML generation library. Since then, I have restructured the blaze-builder library to serve as a drop-in replacement for Data.Binary.Builder, <i>which it improves upon with respect to both speed as well as expressivity</i>.

</div>
<span class="Apple-style-span"><span class="Apple-style-span" style="font-size: x-large;">Usage example</span></span>
We start by importing the necessary modules. We also define a convenient abbreviation for <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">mappend</span>, which actually will become part of the base library according to rumors I heard at this years ZuriHac.

<script src="https://gist.github.com/664979.js?file=BuilderImports.hs">
</script> Our example is about serializing a <i>very</i> simple representation of a person to a sequence of bytes. As usual, this serialization also requires us to fix the encoding format. We encode strings using UTF-8 and prefix them with their length encoded as a 32bit little-endian integer to make parsing unambiguous. We also encode the age of a person as a 32bit little-endian integer. I guess the code speaks for itself.

<script src="https://gist.github.com/664979.js?file=SerializePeople.hs">
</script> The above code is typical for serialization code based on builders. One uses the predefined functions for creating builders with a fixed encoding format from standard Haskell values. These builders are then combined using the functions from the <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">Monoid</span> typeclass. Builders essentially store the recipe for building their corresponding sequence of bytes. Once one needs a concrete representation of this sequence of bytes, one just calls <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><a href="http://hackage.haskell.org/packages/archive/blaze-builder/0.2.0.0/doc/html/Blaze-ByteString-Builder.html#v:toLazyByteString">toLazyByteString</a></span> or <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><a href="http://hackage.haskell.org/packages/archive/blaze-builder/0.2.0.0/doc/html/Blaze-ByteString-Builder.html#v:toByteString">toByteString</a></span> to execute that recipe.

The benefit of using builders to construct a bytestring is twofold: <i>First</i>, appending two builders is an <i>O(1) </i>operation, which is also efficient in absolute terms, as it corresponds to a single function call. <i>Second</i>, when constructing the resulting lazy bytestring the blaze-builder makes sure that the average chunk size is large.&nbsp;A large average chunk size is important to make good use of cache prefetching in later processing steps (e.g. compression) and it also reduces the sytem call overhead when writing the resulting lazy bytestring to a file or sending it over the network.

For example, the above code results in the following sequence of chunk sizes.

<script src="https://gist.github.com/664979.js?file=ExampleChunkSizes.hs">
</script> The 170001 bytes represented by <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">lazyBinaryCloneVillage</span>&nbsp;feature an average chunk size of ~24kb. The first buffer is only ~4kb large, because for short output sequences the buffer allocation cost is significant. <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">toLazyByteString</span> compensates this cost by allocating the first buffer with the minimal expected chunk size. Note that these chunk sizes reflect the default settings of <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">toLazyByteString</span>, which is  optimized to yield efficient and well-chunked results for all lengths of output sequences. If you know more about your typical serialization tasks, then you can tune these settings to your favor.

Speaking of efficiency, I'm quite sure you would also like to see some benchmark figures. I'm not going to present the figures for the above example. Not because they are embarassing; they are not. However, without good competition, the interpretation of benchmark figures is difficult; and currently, I don't know of a good competitor for the above usecase. However, we can also use builders to pack a <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">[Word8]</span> list into a strict or lazy bytestring; and there, we definitely do have good competitors.

<span class="Apple-style-span"><span class="Apple-style-span" style="font-size: x-large;">Packing [Word8]</span></span>
For our benchmark, we use the following implementations for packing <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">[Word8]</span> lists. <script src="https://gist.github.com/664979.js?file=PackingWord8Lists.hs">
</script>
The implementations <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><a href="http://hackage.haskell.org/packages/archive/bytestring/0.9.1.4/doc/html/Data-ByteString.html#v%3Apack">S.pack</a></span>, <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><a href="http://hackage.haskell.org/packages/archive/bytestring/0.9.1.4/doc/html/Data-ByteString-Lazy.html#v%3Apack">L.pack</a></span>, <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">declPackLazy</span>, and <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">binaryDeclPackLazy</span> are trivial. The implementations&nbsp;<span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">packStrict</span> and <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">packLazy</span> make use of &nbsp;<span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><a href="http://hackage.haskell.org/packages/archive/blaze-builder/0.2.0.0/doc/html/Blaze-ByteString-Builder-Word.html#v:fromWord8s">fromWord8s</a> :: [Word8] -&gt; Builder</span>, which is a very efficient function to serialize lists of bytes, as the following plot shows.
<div class="separator" style="clear: both; text-align: center;">
<a href="http://2.bp.blogspot.com/_T2L_i2tnBpo/TNa-lrr8TiI/AAAAAAAAADc/9DfI_9DnqMA/s1600/packing-%5Bword8%5D-scaling-640x480.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/_T2L_i2tnBpo/TNa-lrr8TiI/AAAAAAAAADc/9DfI_9DnqMA/s1600/packing-%5Bword8%5D-scaling-640x480.png" /></a></div>

The plot is a log-log plot of the mean time for packing <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">[Word8]</span> lists using the above implementations when being run on a Core2 Duo T7500 with 2GB RAM and Linux 2.6.32-24 i686 and GHC 6.12.3. I created this plot by adapting <a href="http://www.serpentine.com/blog/">Bryon O'Sullivan's</a> excellent <a href="http://hackage.haskell.org/package/criterion">Criterion</a> benchmarking library to handle scaling benchmarks (cf. <a href="https://github.com/meiersi/blaze-builder/blob/master/Criterion/ScalingBenchmark.hs">ScalingBenchmarks.hs</a>). In the spirit of Criterion, I also generate a <a href="http://en.wikipedia.org/wiki/Box_plot">boxplot</a> version for every scaling benchmark (using more transparent lines to draw the quartiles and whiskers), which allows us to judge the quality of the measurements. The <a href="http://picasaweb.google.com/lh/photo/ABkR1Zurb_MQVHoOJWO4jG3HmNKmvCZV2w4tMH0gGeY?feat=directlink">boxplot version of the above plot</a> shows that nothing went wrong during its measurement.

Note that the mean times are plotted with respect to a logarithmic scale. Hence, a constant difference between two graphs means a <i>constant factor improvement</i>. As you can see from the <a href="https://gist.github.com/664979#file_packing_word8_lists_results.txt">measurement log</a>, using blaze-builder is a definitive win for output sequences longer than&nbsp;1kb: <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">packStrict</span> beats <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">S.pack</span> by almost a factor 2 and <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">packLazy</span> beats <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">L.pack</span> by a factor 10 and <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">binaryDeclPackLazy</span> by a factor 92 (!).

The crucial ingredient for this improvement is the <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">fromWord8s</span> function. <script src="https://gist.github.com/664979.js?file=fromWord8s.hs">
</script> It is constructed using the <a href="http://hackage.haskell.org/packages/archive/blaze-builder/0.2.0.0/doc/html/Blaze-ByteString-Builder-Write.html#t:Write"><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">Write</span> abstraction</a> Jasper introduced during his work on blaze-html. The function <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><a href="http://hackage.haskell.org/packages/archive/blaze-builder/0.2.0.0/doc/html/Blaze-ByteString-Builder-Write.html#v:fromWrite8List">fromWrite8List</a></span>&nbsp;forces and writes eight list elements at a time, which allows the compiler to bundle the actual writes to the output buffer.

For shorter output sequences, the improvement gained from using blaze-builder gets smaller and <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">S.pack</span> is even faster for very short sequences. The following plot, its <a href="http://picasaweb.google.com/lh/photo/vr9lrsLdloyQion59V-jIW3HmNKmvCZV2w4tMH0gGeY?feat=directlink">boxplot version</a>, and the <a href="https://gist.github.com/664979#file_packing_short_word8_lists_results.txt">measurement log</a> give a more detailed comparison for such short sequences.
<a href="http://4.bp.blogspot.com/_T2L_i2tnBpo/TNSSTXQYqyI/AAAAAAAAABA/_Rec6uv_AGY/s1600/packing-short-%5Bword8%5D-lists-scaling-640x480.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/_T2L_i2tnBpo/TNSSTXQYqyI/AAAAAAAAABA/_Rec6uv_AGY/s1600/packing-short-%5Bword8%5D-lists-scaling-640x480.png" /></a>




The results are not surprising when comparing the implementations:&nbsp;<span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">packStrict</span> uses <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><a href="http://hackage.haskell.org/packages/archive/blaze-builder/0.2.0.0/doc/html/Blaze-ByteString-Builder.html#v:toByteString">toByteString</a></span>, which simply runs <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><a href="http://hackage.haskell.org/packages/archive/blaze-builder/0.2.0.0/doc/html/Blaze-ByteString-Builder.html#v:toLazyByteString">toLazyByteString</a></span> and copies all chunks into a single buffer of the appropriate size. Hence, <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">packStrict</span> is always slightly slower than <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">packLazy</span>. The&nbsp;<span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><a href="http://hackage.haskell.org/packages/archive/bytestring/0.9.1.4/doc/html/src/Data-ByteString.html#pack">S.pack</a></span>&nbsp;function from <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">Data.ByteString</span> works in two passes over the input list: first, it determines the length of the list and then it copies all bytes to the allocated buffer. Traversing linked lists of bytes is costly and pays off only for very short lists, as there the output buffer allocation cost is dominant. The peak of <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">packLazy</span> at 64 bytes stems from the fact that it first allocates a 64 byte buffer which is copied to a 4kb buffer once its clear that more than 64 bytes are output. This is done to compensate the buffer allocation cost for very short output sequences. It can be switched off using <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><a href="http://hackage.haskell.org/packages/archive/blaze-builder/0.2.0.0/doc/html/Blaze-ByteString-Builder.html#v:toLazyByteStringWith">toLazyByteStringWith</a></span>, if required.

<span class="Apple-style-span" style="font-size: x-large;">Conclusions</span>
The blaze-builder library provides an <i>expressive and efficient</i>&nbsp;way to construct both lazy as well as strict bytestrings. The <a href="https://github.com/meiersi/blaze-builder/tree/master/benchmarks">accompanying benchmarks</a> show that it improves (often significantly) in all cases over <a href="http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/Data-Binary-Builder.html"><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">Data.Binary.Builder</span></a>&nbsp;from the <a href="http://hackage.haskell.org/package/binary">binary</a> package.&nbsp;The benchmarks presented in this post also show that the implementation of blaze-builder compares favorably against special purpose functions for packing&nbsp;<span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">[Word8]</span>&nbsp;lists;&nbsp;<i>on a Core2 Duo T7500 with 2GB RAM and Linux 2.6.32-24 i686 and GHC 6.12.3. </i>Yeah, that's what the benchmarks state ;-). However, I expect that the conclusions drawn from them stay also valid for most other settings. For example, the GHC-7.0.1 release candidate makes D<span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">ata.ByteString.Builder</span> run a bit faster, but still not as fast as blaze-builder.

During the work on blaze-html, I learned from several benchmarks that ensuring a large average chunk size is <i>very important</i> for lazy bytestrings to be efficient. However, many encoding functions on Hackage produce bytestrings or lazy bytestrings. Hence, we have to copy their result again to guarantee large average chunk sizes, which is a waste of resources. Hence, I suggest that&nbsp;encoding functions produce a builder instead of strict or lazy bytestrings. Apart from guaranteeing a fast append and a large average chunk size, this change also simplifies and generalizes the encoding code, as it separates the buffer allocation strategy from the encoding function.

In order for such a change to be effective, I suggest that the <a href="http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bytestring">bytestring</a> library itself provides an implementation of <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">Data.ByteString.Builder<span class="Apple-style-span" style="font-family: 'Times New Roman';">,</span>&nbsp;</span>which&nbsp;would provide a blessed way to incrementally create bytestrings. The blaze-builder library offers one possible implementation path for such a bytestring builder. If the community would see it fit, then I'd be happy to port the builder parts to the bytestring library. The string encodings currently provided by blaze-builder would then move into their own libraries.

Well that's it for now. I will publish more of the experiments I have done during the work on blaze-builder once I find some more time. I'm also looking very much forward to your feedback.

Happy packing :-p
