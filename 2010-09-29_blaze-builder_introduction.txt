The `blaze-builder` library: (more) efficiently constructing lazy bytestrings
=======================================================================================

NOTE to build in:
  - Builder is the bases for a serialization library.

Hello dear reader, I am [Simon Meier](http://people.inf.ethz.ch/meiersi), a
swiss Haskell enthusiast currently pursuing his PhD in computer science at ETH
Zurich. In this blog post, I'll introduce you to the
[`blaze-builder`](http://hackage.haskell.org/package/blaze-builder) library.

Typically, you would use this library to *efficiently* construct streams of
bytes represented as a lazy bytestring. For example, to save your application
state in a space efficient binary form to a file or to send a response to some
request over the network. 

Probably, you know about the
[`binary`](http://hackage.haskell.org/package/binary-0.5.0.2) package, which
provides the
[`Data.Binary.Builder`](http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/Data-Binary-Builder.html)
module targeting exactly the above use-case. This is no coincidence.  During
this year's Google Summer of Code, [Jasper Van der
Jeugt](http://jaspervdj.be) and I developed the `blaze-buider` library to
overcome performance shortcomings of `Data.Binary.Builder` with respect to the
specific needs of the [`blaze-html`](http://jaspervdj.be/blaze) HTML templating
library. Since then, I have restructured the `blaze-builder` library to serve
as a drop-in replacement for `Data.Binary.Builder`, *which it improves upon
with respect to both speed as well as expressivity*.

This first blog post about the `blaze-builder` library features a simple usage
example to get you acquinted with the library as well as a comparison of the
performance between `blaze-builder` and `binary`.

In the next blog post, I will then explain how the `blaze-builder` library is
implemented.  Intuitively, its implementation can be seen as a neat abstraction of
buffered output. However, more about that in the next post.


Usage example
-------------

Let us first install the newest version (0.2.0.0) of the
[`blaze-builder`](http://hackage.haskell.org/package/blaze-builder) library

~~~
  cabal install blaze-builder
~~~

and import its main module as well as the UTF-8 encoding module.

~~~ { .haskell }
  import Text.Blaze.Builder
  import Text.Blaze.Builder.Char.Utf8
~~~

The `Text.Blaze.Builder` modules provides you with a type `Builder` that allows
to efficiently construct lazy bytestrings with a large average chunk size.

Intuitively, a `Builder` denotes the construction of a part of a lazy
bytestring. Builders can either be created using one of the primitive
combinators in `Text.Blaze.Builder.Write` or by using one of the predefined
combinators for standard Haskell values (see the exposed modules of this
package).  Concatenation of builders is done using `mappend` from the
`Monoid` typeclass.

Here is a small example that serializes a list of strings using the UTF-8
encoding.

~~~ { .haskell }
  serializeString :: String -> Builder
  serializeString ss = fromInt (length ss) `mappend` fromString ss
~~~

Let's assume, we are given a large list of rather short strings and we would
like to concatenate all of them and UTF-8 encode the resulting string. Tasks
like this occur for example when rendering a HTML template. For the sake of
simplicity let us assume that this list of `strings` is defined as follows.

~~~ { .haskell }
  strings :: [String]
  strings = replicate 10000 "Hello there!"
~~~

The function `fromString :: String -> Builder` creates a `Builder` denoting the
UTF-8 encoded argument. Hence, UTF-8 encoding and concatenating all @strings@
can be done follows.

~~~ { .haskell }
  concatenation :: Builder
  concatenation = mconcat $ map fromString strings
~~~

The function 'toLazyByteString'  can be used to execute a `Builder` and
obtain the resulting lazy bytestring.

~~~ { .haskell }
  result :: L.ByteString
  result = toLazyByteString concatenation
~~~

The @result@ is a lazy bytestring containing 10000 repetitions of the string
@\"Hello there!\"@ encoded using UTF-8. The corresponding 120000 bytes are
distributed among three chunks of 32kb and a last chunk of 6kb.


Comparison to the `binary` library
----------------------------------


